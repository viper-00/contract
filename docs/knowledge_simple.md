# 智能合约 - 知识点

学习课程：https://cryptozombies.io/

## 字符串

String：字符串用于保存任意长度的 UTF-8 编码数据。

## 数组

Public 数组, Solidity 会自动创建 getter 方法。

## 私有/公共函数

- **Public**
- **_Private**

## 事件

事件是合约和区块链通讯的一种机制。前端应用监听某些事件，并做出反应。

## 函数修饰符

### 可见性修饰符

- **Private**：合约内部调用。
- **Internal**：合约内部调用，能被继承的合约调用。
- **External**：外部合约调用。
- **Public**：任何地方调用，无论外部还是内部。

### 状态修饰符

- **View**：运行这个函数不会更改和保存任何数据。
- **Pure**：运行这个函数不但不会往区块链写数据，它甚至不从区块链读取数据。

注意：这两种在被外部合约调用时候不花费任何 gas，但从内部其他函数调用时会耗费 gas。

### 自定义 Modifiers

如 onlyOwner、aboveLevel：自定义对函数的约束逻辑。

## Payable

Payable：接收以太的特殊函数。

在以太坊中， 因为钱（以太）和数据（事务负载），以及合约代码本身都存在于以太坊。Payable 可以同时调用函数并付钱给另外一个合约。

例如向一个合约要求支付一定的钱来运行一个函数。

注意：如果一个函数没标记为 **payable**， 而你尝试发送以太，函数将拒绝你的事务。

- **this.balance** 将返回当前合约存储了多少以太。
- **transfer** 向任何以太坊地址付钱。

## 随机数

用 **keccak256** 来制造随机数，随机数生成器是 keccak256 哈希函数。

```js
// 生成一个 0 到 100 的随机数:
uint randNonce = 0;
uint random = uint(keccak256(now, msg.sender, randNonce)) % 100;
randNonce++;
uint random2 = uint(keccak256(now, msg.sender, randNonce)) % 100;
```

## 代币

一个代币在以太坊基本上就是一个遵循一些共同规则的智能合约——即它实现了所有其他代币合约共享的一组标准函数，例如 transfer(address _to, uint256 _value) 函数和 balanceOf(address _owner) 函数.

### ERC20 代币

由于所有 ERC20 代币共享具有相同名称的同一组函数，它们都可以以相同的方式进行交互。这意味着如果你构建的应用程序能够与一个 ERC20 代币进行交互，那么它就也能够与任何 ERC20 代币进行交互。

### ERC721 代币

ERC721 代币是不能互换的，因为每个代币都被认为是唯一且不可分割的。你只能以整个单位交易它们，并且每个单位都有唯一的 ID。 这些特性正好让我们的僵尸可以用来交易。

使用像 ERC721 这样的标准的优势就是，我们不必在我们的合约中实现拍卖或托管逻辑。

## 合约安全措施

溢出（overflow）：假设我们有一个 uint8, 只能存储 8bit 数据。这意味着我们能存储的最大数字就是二进制 11111111 (也就是十进制的 2^8 - 1 = 255)。

```js
uint8 number = 255;
number++; // 出现溢出错误
```

下溢（underflow）：如果你从一个等于 0 的 uint8 减去 1, 它将变成 255 (因为 uint 是无符号的，其不能等于负数)。

```js
uint8 number = 0;
number--; // 出现下溢错误
```

## SafeMath

OpenZeppelin 建立了一个叫做 SafeMath 的库（library），主要有四个方法：add、sub、mul、div。

## Assert 和 Require 的区别

Assert 和 Require 区别在于，Require 若失败则会返还给用户剩下的 gas，Assert 则不会。所以大部分情况下，你写代码的时候会比较喜欢 Require，Assert 只在代码可能出现严重错误的时候使用，比如 uint 溢出。

## 注释

natspec 格式

```
@title（标题）
@author（作者）
@notice（须知）向用户解释这个方法或者合约是做什么的
@dev（开发者）是向开发者解释更多的细节
@param（参数）
@return（返回） 用来描述这个方法需要传入什么参数以及返回什么值。
```

## 合约

Web3.js 需要两个东西来和合约对话：地址和 ABI。

- 合约地址：部署合约区块链上的地址。
- 合约 ABI：ABI 意为应用二进制接口（Application Binary Interface）。 基本上，它是以 JSON 格式表示合约的方法，告诉 Web3.js 如何以合同理解的方式格式化函数调用。

以太坊节点只能识别一种叫做 **JSON-RPC** 的语言：

```json
{"jsonrpc":"2.0","method":"eth_sendTransaction","params":[{"from":"0xb60e8dd61c5d32be8058bb8eb970870f07233155","to":"0xd46e8dd67c5d32be8058bb8eb970870f07244567","gas":"0x76c0","gasPrice":"0x9184e72a000","value":"0x9184e72a","data":"0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675"}],"id":1}
```

## Wei

一个 Wei 是以太的最小单位，1 ether 等于 10^18 Wei。

## Web3.js

Ethereum JavaScript API：https://github.com/ChainSafe/web3.js

## Web3 提供者(Web3 Provider)

在 Web3.js 里设置 Web3 的 Provider（提供者）告诉代码应该和哪个节点交互来处理读写。

### Infura

[Infura](https://infura.io/)  是一个服务，它维护了很多以太坊节点并提供了一个缓存层来实现高速读取。可以用他们的 API 来免费访问这个服务。 用 Infura 作为节点提供者，你可以不用自己运营节点就能很可靠地向以太坊发送、接收信息。

> 注意: 以太坊 (以及通常意义上的 blockchains )使用一个公钥/私钥对来对给事务做数字签名。把它想成一个数字签名的异常安全的密码。这样当我修改区块链上的数据的时候，我可以用我的公钥来证明我就是签名的那个。但是因为没人知道私钥，所以没人能伪造事务。

### Metamask

[Metamask](https://metamask.io/)  是 Chrome 和 Firefox 的浏览器扩展，它能让用户安全地维护自己的以太坊账户和私钥， 并用他们的账户和支持 Web3.js 的网站互动。

Web 检查示例脚本：

```js
window.addEventListener('load', function() {

  // 检查web3是否已经注入到(Mist/MetaMask)
  if (typeof web3 !== 'undefined') {
    // 使用 Mist/MetaMask 的提供者
    web3js = new Web3(web3.currentProvider);
  } else {
    // 处理用户没安装的情况， 比如显示一个消息
    // 告诉他们要安装 MetaMask 来使用我们的应用
  }

  // 现在你可以启动你的应用并自由访问 Web3.js:
  startApp()

})
```

## Indexed

为了筛选仅和当前用户相关的事件，Solidity 合约必须使用 indexed 关键字。

```solidity
event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);
```

## Addresses（地址）

特定用户，或智能合约的地址。

## Mapping（映射）

映射本质上是存储和查找数据所用的键-值对。

## msg.sender

指当前调用者（或智能合约）的 address。

在 Solidity 中，执行函数始终需要从外部调用者开始。 一个合约只会在区块链上什么也不做，除非有人调用其中的函数。所以 **msg.sender** 总是存在的。

使用 msg.sender 很安全，因为它具有以太坊区块链的安全保障 —— 除非窃取与以太坊地址相关联的私钥，否则是没有办法修改其他人的数据。

## Require

Require 使得函数在执行过程中，当不满足某些条件时抛出错误，并停止执行。

因此，在调用一个函数之前，用 Require 验证前置条件是非常有必要的。

## 继承（Inheritance）

当代码过于冗长的时候，最好将代码和逻辑分拆到多个不同的合约中，以便于管理。

## 引入（Import）

在 Solidity 中，当你有多个文件并且想把一个文件导入另一个文件时，可以使用 import 语句

## 存储变量（storage、memory）

**Storage** 变量是指永久存储在区块链中的变量，**Memory** 变量则是临时的，当外部函数对某合约调用完成时，内存型变量即被移除。

大多数时候你都用不到这些关键字，默认情况下 Solidity 会自动处理它们。 状态变量（在函数之外声明的变量）默认为**存储**形式，并永久写入区块链；而在函数内部声明的变量是**内存**型的，它在函数调用结束后消失。

状态变量是被永久地保存在合约中，也就是说它们被写入以太币区块链中，可以想象成写入一个数据库内。

## 智能合约的永固性

在你把智能协议传上以太坊之后，它就变得**不可更改**, 这种永固性意味着你的代码永远不能被调整或更新。

编译的程序会一直的、永久的、不可更改的，存储在以太坊上。这就是 Solidity 代码的安全性如此重要的一个原因。如果你的智能协议有任何漏洞，即使你发现了也无法补救。你只能让你的用户们放弃这个智能协议，然后转移到一个新的修复后的合约上。

但这恰好也是智能合约的一大优势。代码说明一切。如果你去读智能合约的代码，并验证它，你会发现，一旦函数被定义下来，每一次的运行，程序都会严格遵照函数中原有的代码逻辑一丝不苟地执行，完全不用担心函数被人篡改而得到意外的结果。

## OpenZeppelin 库的 Ownable 合约

OpenZeppelin 是主打安保和社区审查的智能合约库。

所以非常重要的是，部署在以太坊上的 DApp，并不能保证它真正做到去中心化，你需要阅读并理解它的源代码，才能防止其中没有被部署者恶意植入后门。

作为开发人员，如何做到既要给自己留下修复 bug 的余地，又要尽量地放权给使用者，以便让他们放心，从而愿意把数据放在你的 DApp 中，这确实需要个微妙的平衡。

## Gas

在 Solidity 中，你的用户想要每次执行你的 DApp 都需要支付一定的 **gas** 费，gas 可以用以太币购买，因此，用户每次跑 DApp 都得花费以太币。

一次操作所需要花费的 **gas** 费等于这个操作背后的所有运算花销的总和。存储数据比做加法运算贵得多。

由于运行你的程序需要花费用户的真金白银，所以在以太坊中代码的编程语言，比其他任何编程语言都更强调优化。同样的功能，使用笨拙的代码开发的程序，比起经过精巧优化的代码来说，运行花费更高，因为这显然会给成千上万的用户带来大量不必要的开销。

如果你使用侧链，倒不一定需要付费。比如 Loom Network 上构建的 CryptoZombies 就是免费的。

如果一个 **view** 函数在另一个函数的内部被调用，而调用函数与 **view** 函数的不属于同一个合约，也会产生调用成本。这是因为如果主调函数在以太坊创建了一个事务，它仍然需要逐个节点去验证。所以标记为 **view** 的函数只有在外部调用时才是免费的。

## Summary

好好学习，天天向上。

Happy Coding!